<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QilbeeDB - Enterprise Graph Database Documentation</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --success-color: #27ae60;
            --warning-color: #f39c12;
            --bg-color: #ecf0f1;
            --card-bg: #ffffff;
            --text-color: #2c3e50;
            --border-color: #bdc3c7;
            --code-bg: #f8f9fa;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--bg-color);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
        }

        header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 2rem 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        nav {
            background: var(--card-bg);
            padding: 1rem 0;
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        nav ul {
            list-style: none;
            display: flex;
            flex-wrap: wrap;
            gap: 2rem;
        }

        nav a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 600;
            transition: color 0.3s;
        }

        nav a:hover {
            color: var(--secondary-color);
        }

        main {
            padding: 3rem 0;
        }

        section {
            background: var(--card-bg);
            margin-bottom: 2rem;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        h2 {
            color: var(--primary-color);
            font-size: 2rem;
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid var(--secondary-color);
        }

        h3 {
            color: var(--secondary-color);
            font-size: 1.5rem;
            margin-top: 2rem;
            margin-bottom: 1rem;
        }

        h4 {
            color: var(--primary-color);
            font-size: 1.2rem;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .feature-card {
            background: var(--bg-color);
            padding: 1.5rem;
            border-radius: 8px;
            border-left: 4px solid var(--secondary-color);
        }

        .feature-card h4 {
            margin-top: 0;
            color: var(--secondary-color);
        }

        .code-block {
            background: var(--code-bg);
            padding: 1.5rem;
            border-radius: 6px;
            border-left: 4px solid var(--secondary-color);
            overflow-x: auto;
            margin: 1rem 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .code-block pre {
            margin: 0;
        }

        .api-method {
            background: var(--bg-color);
            padding: 1.5rem;
            margin: 1rem 0;
            border-radius: 6px;
            border-left: 4px solid var(--success-color);
        }

        .api-method .signature {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: var(--primary-color);
            margin-bottom: 0.5rem;
        }

        .parameter-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        .parameter-table th,
        .parameter-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        .parameter-table th {
            background: var(--primary-color);
            color: white;
            font-weight: 600;
        }

        .parameter-table tr:hover {
            background: var(--bg-color);
        }

        .badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 600;
            margin-right: 0.5rem;
        }

        .badge-success {
            background: var(--success-color);
            color: white;
        }

        .badge-warning {
            background: var(--warning-color);
            color: white;
        }

        .badge-danger {
            background: var(--accent-color);
            color: white;
        }

        .badge-info {
            background: var(--secondary-color);
            color: white;
        }

        .alert {
            padding: 1rem;
            border-radius: 6px;
            margin: 1rem 0;
            border-left: 4px solid;
        }

        .alert-info {
            background: #d1ecf1;
            border-color: #0c5460;
            color: #0c5460;
        }

        .alert-warning {
            background: #fff3cd;
            border-color: #856404;
            color: #856404;
        }

        .alert-success {
            background: #d4edda;
            border-color: #155724;
            color: #155724;
        }

        footer {
            background: var(--primary-color);
            color: white;
            padding: 2rem 0;
            text-align: center;
            margin-top: 3rem;
        }

        .architecture-diagram {
            background: white;
            padding: 2rem;
            border-radius: 8px;
            border: 2px solid var(--border-color);
            margin: 2rem 0;
            text-align: center;
        }

        .layer {
            background: var(--bg-color);
            padding: 1rem;
            margin: 0.5rem 0;
            border-radius: 6px;
            border-left: 4px solid var(--secondary-color);
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 1.8rem;
            }

            nav ul {
                flex-direction: column;
                gap: 1rem;
            }

            .feature-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>üóÑÔ∏è QilbeeDB</h1>
            <p>Enterprise-Grade Graph Database with Bi-Temporal Agent Memory</p>
            <p style="font-size: 0.9rem; margin-top: 0.5rem;">Version 0.1.0 | Rust 2024 Edition</p>
        </div>
    </header>

    <nav>
        <div class="container">
            <ul>
                <li><a href="#overview">Overview</a></li>
                <li><a href="#architecture">Architecture</a></li>
                <li><a href="#features">Features</a></li>
                <li><a href="#installation">Installation</a></li>
                <li><a href="#quickstart">Quick Start</a></li>
                <li><a href="#sdks">SDKs</a></li>
                <li><a href="#use-cases">Use Cases</a></li>
                <li><a href="#api">API Reference</a></li>
                <li><a href="#protocols">Protocols</a></li>
                <li><a href="#performance">Performance</a></li>
                <li><a href="#security">Security</a></li>
            </ul>
        </div>
    </nav>

    <main class="container">
        <section id="overview">
            <h2>Overview</h2>
            <p>QilbeeDB is a high-performance, enterprise-grade graph database written in Rust, designed specifically for AI agent systems with advanced bi-temporal memory management. It combines the power of graph databases with sophisticated memory architectures to enable AI agents to maintain context, learn from interactions, and evolve over time.</p>

            <div class="alert alert-info">
                <strong>Key Differentiator:</strong> QilbeeDB is the first graph database to natively integrate bi-temporal memory management (event time + transaction time) with support for episodic, semantic, procedural, and factual memory types.
            </div>

            <h3>Why QilbeeDB?</h3>
            <div class="feature-grid">
                <div class="feature-card">
                    <h4>üöÄ Performance</h4>
                    <p>Built in Rust for maximum performance and safety. Zero-cost abstractions and compile-time guarantees.</p>
                </div>
                <div class="feature-card">
                    <h4>üß† Agent Memory</h4>
                    <p>Native support for AI agent memory with automatic consolidation, relevance decay, and active forgetting.</p>
                </div>
                <div class="feature-card">
                    <h4>üîÑ Bi-Temporal</h4>
                    <p>Track both when events occurred (event time) and when they were recorded (transaction time) for complete auditability.</p>
                </div>
                <div class="feature-card">
                    <h4>üìä OpenCypher</h4>
                    <p>Full OpenCypher query language support for powerful graph traversals and pattern matching.</p>
                </div>
                <div class="feature-card">
                    <h4>‚ö° RocksDB Backend</h4>
                    <p>Leverages RocksDB for high-performance storage with compression, bloom filters, and write-ahead logging.</p>
                </div>
                <div class="feature-card">
                    <h4>üîå Multiple Protocols</h4>
                    <p>Bolt (Neo4j-compatible), HTTP REST API, and gRPC support for maximum interoperability.</p>
                </div>
            </div>
        </section>

        <section id="architecture">
            <h2>Architecture</h2>

            <div class="architecture-diagram">
                <h3 style="margin-top: 0;">Layered Architecture</h3>

                <div class="layer">
                    <strong>Protocol Layer</strong>
                    <p>Bolt | HTTP/REST | gRPC</p>
                </div>

                <div class="layer">
                    <strong>Query Engine</strong>
                    <p>OpenCypher Parser ‚Üí AST ‚Üí Optimizer ‚Üí Executor</p>
                </div>

                <div class="layer">
                    <strong>Graph Engine</strong>
                    <p>Graph Management | Node/Relationship Operations | Transactions</p>
                </div>

                <div class="layer">
                    <strong>Memory Engine</strong>
                    <p>Episodic | Semantic | Procedural | Factual Memory</p>
                </div>

                <div class="layer">
                    <strong>Storage Engine</strong>
                    <p>RocksDB | Column Families | Indexes | WAL</p>
                </div>
            </div>

            <h3>Core Components</h3>

            <h4>1. qilbee-core</h4>
            <p>Foundational types and traits shared across all crates.</p>
            <ul>
                <li><strong>Types:</strong> Node, Relationship, Property, GraphId, EntityId</li>
                <li><strong>Temporal:</strong> EventTime, TransactionTime, BiTemporal, TemporalRange</li>
                <li><strong>Error Handling:</strong> Result, Error enum with detailed error codes</li>
            </ul>

            <h4>2. qilbee-storage</h4>
            <p>High-performance storage engine built on RocksDB.</p>
            <ul>
                <li><strong>Column Families:</strong> Nodes, Relationships, Label Index, Adjacency (In/Out), Property Index, Schema, Meta, Memory</li>
                <li><strong>Key Encoding:</strong> Binary key encoding with prefix-based iteration</li>
                <li><strong>Transactions:</strong> ACID transactions with optimistic concurrency control</li>
                <li><strong>Optimizations:</strong> Bloom filters, compression (LZ4), write batching</li>
            </ul>

            <h4>3. qilbee-graph</h4>
            <p>Graph database operations and management.</p>
            <ul>
                <li><strong>Multi-Graph:</strong> Support for multiple independent graphs in one database</li>
                <li><strong>CRUD Operations:</strong> Create, Read, Update, Delete for nodes and relationships</li>
                <li><strong>Traversal:</strong> BFS, DFS, shortest path, pattern matching</li>
                <li><strong>Indexes:</strong> Label indexes, property indexes, composite indexes</li>
            </ul>

            <h4>4. qilbee-memory</h4>
            <p>Bi-temporal agent memory management.</p>
            <ul>
                <li><strong>Memory Types:</strong> Episodic (events), Semantic (concepts), Procedural (workflows), Factual (facts)</li>
                <li><strong>Consolidation:</strong> Automatic STM ‚Üí LTM consolidation based on relevance</li>
                <li><strong>Forgetting:</strong> Active forgetting with relevance decay algorithms</li>
                <li><strong>Time-Travel:</strong> Query memory at any point in time (event or transaction)</li>
            </ul>

            <h4>5. qilbee-query</h4>
            <p>Enterprise-grade OpenCypher query engine with cost-based optimization.</p>
            <ul>
                <li><strong>Parser:</strong> Recursive descent parser supporting MATCH, WHERE, RETURN, ORDER BY, LIMIT</li>
                <li><strong>Planner:</strong> Cost-based query planner with cardinality estimation and index selection</li>
                <li><strong>Optimizer:</strong> Advanced optimizations including predicate pushdown, join ordering, common subexpression elimination</li>
                <li><strong>Executor:</strong> Vectorized execution engine with lazy evaluation and streaming results</li>
                <li><strong>Physical Operators:</strong> NodeScan, IndexSeek, IndexScan, Filter, Project, Expand, HashJoin, NestedLoopJoin, OrderBy, Limit, Skip, Distinct, Aggregate</li>
                <li><strong>Statistics:</strong> Execution statistics tracking (nodes scanned, index hits, cache hits, execution time)</li>
            </ul>

            <h4>6. qilbee-protocol</h4>
            <p>Network protocol implementations.</p>
            <ul>
                <li><strong>Bolt:</strong> Neo4j-compatible binary protocol (v4.4)</li>
                <li><strong>HTTP:</strong> RESTful JSON API</li>
                <li><strong>gRPC:</strong> High-performance binary protocol (planned)</li>
            </ul>

            <h4>7. qilbee-server</h4>
            <p>Server runtime and connection management.</p>
            <ul>
                <li><strong>Async Runtime:</strong> Tokio-based async I/O</li>
                <li><strong>Connection Pool:</strong> Efficient connection management</li>
                <li><strong>Auth:</strong> Authentication and authorization</li>
                <li><strong>Monitoring:</strong> Metrics, tracing, health checks</li>
            </ul>
        </section>

        <section id="features">
            <h2>Features</h2>

            <h3>Graph Database Features</h3>
            <ul>
                <li>‚úÖ <strong>Property Graph Model:</strong> Nodes and relationships with typed properties</li>
                <li>‚úÖ <strong>Multiple Labels:</strong> Nodes can have multiple labels for flexible typing</li>
                <li>‚úÖ <strong>Directed Relationships:</strong> All relationships have direction with type names</li>
                <li>‚úÖ <strong>ACID Transactions:</strong> Full ACID compliance with snapshot isolation</li>
                <li>‚úÖ <strong>Indexes:</strong> Label indexes, property indexes, composite indexes</li>
                <li>‚úÖ <strong>Constraints:</strong> Unique constraints, existence constraints (planned)</li>
                <li>‚úÖ <strong>OpenCypher:</strong> Industry-standard query language</li>
            </ul>

            <h3>Memory Management Features</h3>
            <ul>
                <li>‚úÖ <strong>Bi-Temporal Model:</strong> Event time + Transaction time tracking</li>
                <li>‚úÖ <strong>Four Memory Types:</strong> Episodic, Semantic, Procedural, Factual</li>
                <li>‚úÖ <strong>Automatic Consolidation:</strong> STM ‚Üí LTM based on access patterns</li>
                <li>‚úÖ <strong>Relevance Decay:</strong> Exponential decay with configurable rates</li>
                <li>‚úÖ <strong>Active Forgetting:</strong> Remove low-relevance memories automatically</li>
                <li>‚úÖ <strong>Time-Travel Queries:</strong> Query historical state at any point in time</li>
                <li>‚úÖ <strong>Memory Statistics:</strong> Track memory usage, access patterns, relevance</li>
            </ul>

            <h3>Performance Features</h3>
            <ul>
                <li>‚úÖ <strong>Zero-Copy Deserialization:</strong> Using bincode for efficient serialization</li>
                <li>‚úÖ <strong>Prefix Iteration:</strong> Fast range scans using RocksDB prefix iterators</li>
                <li>‚úÖ <strong>Bloom Filters:</strong> Reduce disk I/O for non-existent keys</li>
                <li>‚úÖ <strong>Compression:</strong> LZ4 compression for storage efficiency</li>
                <li>‚úÖ <strong>Write Batching:</strong> Batch multiple operations for atomicity and performance</li>
                <li>‚úÖ <strong>Async I/O:</strong> Non-blocking operations using Tokio</li>
            </ul>

            <h3>Operational Features</h3>
            <ul>
                <li>‚úÖ <strong>Backup & Recovery:</strong> WAL-based point-in-time recovery</li>
                <li>‚úÖ <strong>Compaction:</strong> Automatic and manual compaction</li>
                <li>‚úÖ <strong>Statistics:</strong> Detailed storage and query statistics</li>
                <li>‚úÖ <strong>Health Checks:</strong> Service health monitoring</li>
                <li>‚úÖ <strong>Tracing:</strong> Distributed tracing support</li>
                <li>‚úÖ <strong>Metrics:</strong> Prometheus-compatible metrics</li>
            </ul>
        </section>

        <section id="installation">
            <h2>Installation</h2>

            <h3>Prerequisites</h3>
            <ul>
                <li><strong>Rust:</strong> Version 1.85.0 or later (Rust 2024 edition)</li>
                <li><strong>Operating System:</strong> Linux, macOS, or Windows</li>
                <li><strong>Memory:</strong> Minimum 4GB RAM, recommended 8GB+</li>
                <li><strong>Disk:</strong> SSD recommended for optimal performance</li>
            </ul>

            <h3>From Source</h3>
            <div class="code-block">
                <pre># Clone the repository
git clone https://github.com/your-org/qilbeedb.git
cd qilbeedb

# Build in release mode
cargo build --release

# Run tests
cargo test --all

# Run the server
cargo run --release --bin qilbee-server</pre>
            </div>

            <h3>Using Cargo</h3>
            <div class="code-block">
                <pre># Add to your Cargo.toml
[dependencies]
qilbee-graph = "0.1.0"
qilbee-memory = "0.1.0"
qilbee-query = "0.1.0"</pre>
            </div>

            <h3>Docker</h3>
            <div class="code-block">
                <pre># Pull the image
docker pull qilbeedb/qilbeedb:latest

# Run the container
docker run -d \
  --name qilbeedb \
  -p 7687:7687 \
  -p 7474:7474 \
  -v qilbeedb-data:/data \
  qilbeedb/qilbeedb:latest</pre>
            </div>
        </section>

        <section id="quickstart">
            <h2>Quick Start</h2>

            <h3>Example 1: Basic Graph Operations</h3>
            <div class="code-block">
                <pre>use qilbee_graph::{Database, Graph};
use qilbee_core::{Node, PropertyValue};

// Open database
let db = Database::open("./data/mydb").unwrap();

// Get or create a graph
let graph = db.graph("social").unwrap();

// Create nodes
let mut alice = graph.create_node(["Person"]).unwrap();
alice.set_property("name", PropertyValue::String("Alice".to_string()));
alice.set_property("age", PropertyValue::Integer(30));
graph.update_node(&alice).unwrap();

let mut bob = graph.create_node(["Person"]).unwrap();
bob.set_property("name", PropertyValue::String("Bob".to_string()));
bob.set_property("age", PropertyValue::Integer(35));
graph.update_node(&bob).unwrap();

// Create relationship
let knows = graph.create_relationship(
    alice.id,
    "KNOWS",
    bob.id
).unwrap();

// Query nodes
let people = graph.find_nodes_by_label("Person").unwrap();
println!("Found {} people", people.len());</pre>
            </div>

            <h3>Example 2: Agent Memory Management</h3>
            <div class="code-block">
                <pre>use qilbee_memory::{AgentMemory, MemoryConfig, Episode};

// Configure agent memory
let config = MemoryConfig::new("agent-001")
    .min_relevance(0.1)
    .max_episodes(10000)
    .no_auto_forget();

let memory = AgentMemory::new(config);

// Store episodic memory
let episode = Episode::conversation(
    "agent-001",
    "What is the capital of France?",
    "The capital of France is Paris."
);
memory.store_episode(episode).unwrap();

// Store observation
let obs = Episode::observation(
    "agent-001",
    "User seems interested in European geography"
);
memory.store_episode(obs).unwrap();

// Retrieve recent memories
let recent = memory.get_recent_episodes(10).unwrap();

// Search memories
let results = memory.search_episodes("France").unwrap();

// Get statistics
let stats = memory.get_statistics().unwrap();
println!("Total episodes: {}", stats.total_episodes);
println!("Average relevance: {:.2}", stats.avg_relevance);</pre>
            </div>

            <h3>Example 3: Transactions</h3>
            <div class="code-block">
                <pre>use qilbee_graph::Database;
use qilbee_core::PropertyValue;

let db = Database::open("./data/mydb").unwrap();
let graph = db.graph("financial").unwrap();

// Begin transaction
let mut tx = db.storage().begin_transaction(graph.id()).unwrap();

// Perform operations
let account1 = graph.create_node(["Account"]).unwrap();
let account2 = graph.create_node(["Account"]).unwrap();

let transfer = graph.create_relationship(
    account1.id,
    "TRANSFERRED_TO",
    account2.id
).unwrap();

// Commit or rollback
if validate_transfer(&transfer) {
    tx.commit().unwrap();
} else {
    tx.rollback().unwrap();
}</pre>
            </div>

            <h3>Example 4: OpenCypher Queries</h3>
            <div class="code-block">
                <pre>use qilbee_query::parse_cypher;
use qilbee_graph::Database;

let db = Database::open("./data/mydb").unwrap();
let graph = db.graph("social").unwrap();

// Parse and execute Cypher query
let query = "
    MATCH (person:Person)-[:KNOWS]->(friend:Person)
    WHERE person.name = 'Alice'
    RETURN friend.name, friend.age
    ORDER BY friend.age DESC
    LIMIT 10
";

let ast = parse_cypher(query).unwrap();
let results = graph.execute_query(ast).unwrap();

for row in results.rows {
    println!("Friend: {}, Age: {}", row[0], row[1]);
}</pre>
            </div>
        </section>

        <section id="sdks">
            <h2>SDKs & Client Libraries</h2>

            <p>QilbeeDB provides official SDKs for multiple programming languages, making it easy to integrate graph database and agent memory capabilities into your applications.</p>

            <h3>Python SDK</h3>
            <p>Full-featured Python client with support for graph operations, Cypher queries, and agent memory management.</p>

            <h4>Installation</h4>
            <div class="code-block">
                <pre># Install from PyPI
pip install qilbeedb

# Or install from source
cd sdks/python
pip install -e .</pre>
            </div>

            <h4>Basic Usage</h4>
            <div class="code-block">
                <pre>from qilbeedb import QilbeeDB

# Connect to QilbeeDB
db = QilbeeDB("http://localhost:7474")

# Get or create a graph
graph = db.graph("my_graph")

# Create nodes
alice = graph.create_node(
    ['Person', 'User'],
    {'name': 'Alice', 'age': 30, 'city': 'San Francisco'}
)

bob = graph.create_node(
    ['Person', 'User'],
    {'name': 'Bob', 'age': 35, 'city': 'New York'}
)

# Create relationship
friendship = graph.create_relationship(
    alice,
    'KNOWS',
    bob,
    {'since': '2020-01-15', 'strength': 0.9}
)

# Query with Cypher
results = graph.query(
    "MATCH (p:Person) WHERE p.age > $min_age RETURN p.name, p.age",
    {"min_age": 25}
)

for row in results:
    print(f"Name: {row['p.name']}, Age: {row['p.age']}")</pre>
            </div>

            <h4>Agent Memory Usage</h4>
            <div class="code-block">
                <pre>from qilbeedb import QilbeeDB
from qilbeedb.memory import Episode

db = QilbeeDB("http://localhost:7474")
memory = db.agent_memory('customer_service_bot')

# Store conversation episodes
episode = Episode.conversation(
    'customer_service_bot',
    'How do I reset my password?',
    'You can reset your password by clicking the "Forgot Password" link on the login page.'
)
episode_id = memory.store_episode(episode)

# Store observations
observation = Episode.observation(
    'customer_service_bot',
    'User seems frustrated with password reset process'
)
memory.store_episode(observation)

# Store actions
action = Episode.action(
    'customer_service_bot',
    'Sent password reset email',
    'Email sent successfully to user@example.com'
)
memory.store_episode(action)

# Retrieve recent episodes
recent = memory.get_recent_episodes(10)
for ep in recent:
    print(f"Type: {ep.episode_type}, Content: {ep.content}")

# Get memory statistics
stats = memory.get_statistics()
print(f"Total episodes: {stats.total_episodes}")
print(f"Average relevance: {stats.avg_relevance}")</pre>
            </div>

            <h4>Query Builder</h4>
            <div class="code-block">
                <pre>from qilbeedb.query import Query

# Build complex queries fluently
result = (
    Query(graph)
    .match('(p:Person)-[:KNOWS]->(f:Person)')
    .where('p.city = $city', {'city': 'San Francisco'})
    .return_clause('f.name', 'f.age')
    .order_by('f.age', desc=True)
    .limit(10)
    .execute()
)

for row in result:
    print(row)</pre>
            </div>

            <h3>SDK Features</h3>
            <div class="feature-grid">
                <div class="feature-card">
                    <h4>üîÑ Connection Management</h4>
                    <p>Automatic connection pooling, retry logic, and health checks</p>
                </div>
                <div class="feature-card">
                    <h4>üìä Graph Operations</h4>
                    <p>CRUD operations for nodes and relationships with property support</p>
                </div>
                <div class="feature-card">
                    <h4>üîç Cypher Queries</h4>
                    <p>Execute Cypher queries with parameter binding and result mapping</p>
                </div>
                <div class="feature-card">
                    <h4>üß† Agent Memory</h4>
                    <p>Native support for episodic, observation, and action-based memory</p>
                </div>
                <div class="feature-card">
                    <h4>üèóÔ∏è Query Builder</h4>
                    <p>Fluent API for building complex queries programmatically</p>
                </div>
                <div class="feature-card">
                    <h4>‚ö° Async Support</h4>
                    <p>Async/await support for non-blocking operations (coming soon)</p>
                </div>
            </div>

            <h3>Coming Soon</h3>
            <ul>
                <li><strong>JavaScript/TypeScript SDK:</strong> Node.js and browser support</li>
                <li><strong>Go SDK:</strong> High-performance Go client library</li>
                <li><strong>Java SDK:</strong> Enterprise Java integration</li>
                <li><strong>.NET SDK:</strong> C# and .NET Core support</li>
                <li><strong>Rust SDK:</strong> Native Rust bindings</li>
            </ul>
        </section>

        <section id="use-cases">
            <h2>Real-World Use Cases</h2>

            <p>QilbeeDB is designed for modern AI-powered applications that require both graph database capabilities and sophisticated memory management. Here are some practical use cases:</p>

            <h3>1. AI Agent Systems</h3>
            <div class="feature-card">
                <h4>Customer Service Bots</h4>
                <p>Build intelligent customer service agents that remember past interactions, learn from conversations, and maintain context across sessions.</p>
                <div class="code-block">
                    <pre># Store customer interaction
episode = Episode.conversation(
    agent_id='support_agent_01',
    user_input='My order #12345 hasn\'t arrived',
    agent_response='I can help with that. Let me check your order status.'
)
memory.store_episode(episode)

# Track decision-making
decision = Episode.action(
    agent_id='support_agent_01',
    action='Initiated refund for order #12345',
    result='Refund processed successfully, $99.99 credited'
)
memory.store_episode(decision)</pre>
                </div>
            </div>

            <h3>2. Social Networks</h3>
            <div class="feature-card">
                <h4>Social Graph Analysis</h4>
                <p>Model complex social relationships, friend networks, and user interactions with multiple labels and rich properties.</p>
                <div class="code-block">
                    <pre># Create social network
alice = graph.create_node(
    ['User', 'Person'],
    {'username': 'alice', 'name': 'Alice Johnson', 'age': 28}
)

bob = graph.create_node(
    ['User', 'Person'],
    {'username': 'bob', 'name': 'Bob Smith', 'age': 32}
)

# Create friendship with metadata
friendship = graph.create_relationship(
    alice, 'FRIEND', bob,
    {'since': '2023-02-25', 'strength': 0.8}
)

# Query friends of friends
results = graph.query("""
    MATCH (user:User {username: $username})-[:FRIEND]->(friend)-[:FRIEND]->(fof)
    WHERE fof.username <> $username
    RETURN fof.name, fof.username
    LIMIT 10
""", {"username": "alice"})</pre>
                </div>
            </div>

            <h3>3. Knowledge Graphs</h3>
            <div class="feature-card">
                <h4>Enterprise Knowledge Management</h4>
                <p>Build semantic knowledge graphs for concepts, relationships, and domain knowledge with bi-temporal tracking.</p>
                <div class="code-block">
                    <pre># Create knowledge graph
python = graph.create_node(
    ['Concept', 'ProgrammingLanguage'],
    {'name': 'Python', 'paradigm': 'multi-paradigm', 'year': 1991}
)

web_dev = graph.create_node(
    ['Concept', 'Domain'],
    {'name': 'Web Development', 'category': 'software'}
)

# Semantic relationship
graph.create_relationship(
    python, 'USED_FOR', web_dev,
    {'popularity': 0.9, 'since': '1995'}
)</pre>
                </div>
            </div>

            <h3>4. Recommendation Systems</h3>
            <div class="feature-card">
                <h4>Personalized Recommendations</h4>
                <p>Build recommendation engines based on user behavior, purchase history, and collaborative filtering.</p>
                <div class="code-block">
                    <pre># Model user-product interactions
user = graph.create_node(['Customer'], {'user_id': 'U001', 'name': 'Jane'})
laptop = graph.create_node(['Product'], {'product_id': 'P001', 'name': 'Laptop Pro'})

# Track purchase
graph.create_relationship(
    user, 'PURCHASED', laptop,
    {'date': '2024-01-15', 'rating': 5, 'price': 1299.99}
)

# Find similar users and recommend
recommendations = graph.query("""
    MATCH (u:Customer {user_id: $user_id})-[:PURCHASED]->(p:Product)
          <-[:PURCHASED]-(similar:Customer)-[:PURCHASED]->(rec:Product)
    WHERE NOT (u)-[:PURCHASED]->(rec)
    RETURN rec.name, COUNT(similar) as score
    ORDER BY score DESC
    LIMIT 5
""", {"user_id": "U001"})</pre>
                </div>
            </div>

            <h3>5. Workflow & Process Management</h3>
            <div class="feature-card">
                <h4>Business Process Tracking</h4>
                <p>Model and track complex workflows, approvals, and business processes with temporal awareness.</p>
                <div class="code-block">
                    <pre># Create workflow nodes
task = graph.create_node(['Task'], {'task_id': 'T001', 'status': 'pending'})
user = graph.create_node(['User'], {'user_id': 'U001'})

# Assign task
graph.create_relationship(
    task, 'ASSIGNED_TO', user,
    {'assigned_at': '2024-01-15T10:00:00Z', 'priority': 'high'}
)</pre>
                </div>
            </div>

            <h3>6. Multi-Agent Coordination</h3>
            <div class="feature-card">
                <h4>Agent Collaboration Systems</h4>
                <p>Enable multiple AI agents to coordinate, share knowledge, and maintain separate memory spaces.</p>
                <div class="code-block">
                    <pre># Separate memory spaces for different agents
sales_memory = db.agent_memory('sales_agent')
support_memory = db.agent_memory('support_agent')

# Sales agent interaction
sales_ep = Episode.conversation(
    'sales_agent',
    'Interested in enterprise plan',
    'Let me schedule a demo for you'
)
sales_memory.store_episode(sales_ep)

# Support agent interaction
support_ep = Episode.conversation(
    'support_agent',
    'Having trouble logging in',
    'Let me reset your password'
)
support_memory.store_episode(support_ep)</pre>
                </div>
            </div>

            <h3>Use Case Benefits</h3>
            <ul>
                <li><strong>Bi-Temporal Tracking:</strong> Track both when events occurred and when they were recorded</li>
                <li><strong>Rich Relationships:</strong> Model complex relationships with typed properties</li>
                <li><strong>Memory Management:</strong> Automatic consolidation and relevance-based forgetting</li>
                <li><strong>High Performance:</strong> Optimized for both read and write-heavy workloads</li>
                <li><strong>Flexible Schema:</strong> Multi-label nodes and dynamic properties</li>
                <li><strong>ACID Compliance:</strong> Full transactional support for data integrity</li>
            </ul>
        </section>

        <section id="api">
            <h2>API Reference</h2>

            <h3>Database API</h3>

            <div class="api-method">
                <div class="signature">Database::open(path: &Path) ‚Üí Result&lt;Database&gt;</div>
                <p>Opens or creates a database at the specified path.</p>
                <table class="parameter-table">
                    <thead>
                        <tr>
                            <th>Parameter</th>
                            <th>Type</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>path</td>
                            <td>&Path</td>
                            <td>Filesystem path for database storage</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="api-method">
                <div class="signature">Database::graph(&self, name: &str) ‚Üí Result&lt;Graph&gt;</div>
                <p>Gets or creates a graph by name.</p>
            </div>

            <div class="api-method">
                <div class="signature">Database::list_graphs(&self) ‚Üí Result&lt;Vec&lt;String&gt;&gt;</div>
                <p>Lists all graph names in the database.</p>
            </div>

            <div class="api-method">
                <div class="signature">Database::delete_graph(&self, name: &str) ‚Üí Result&lt;bool&gt;</div>
                <p>Deletes a graph and all its data.</p>
            </div>

            <h3>Graph API</h3>

            <div class="api-method">
                <div class="signature">Graph::create_node(&self, labels: &[&str]) ‚Üí Result&lt;Node&gt;</div>
                <p>Creates a new node with the specified labels.</p>
                <table class="parameter-table">
                    <thead>
                        <tr>
                            <th>Parameter</th>
                            <th>Type</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>labels</td>
                            <td>&[&str]</td>
                            <td>Array of label names for the node</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="api-method">
                <div class="signature">Graph::get_node(&self, id: NodeId) ‚Üí Result&lt;Option&lt;Node&gt;&gt;</div>
                <p>Retrieves a node by its ID.</p>
            </div>

            <div class="api-method">
                <div class="signature">Graph::update_node(&self, node: &Node) ‚Üí Result&lt;()&gt;</div>
                <p>Updates an existing node's properties and labels.</p>
            </div>

            <div class="api-method">
                <div class="signature">Graph::delete_node(&self, id: NodeId) ‚Üí Result&lt;bool&gt;</div>
                <p>Deletes a node and all its relationships.</p>
            </div>

            <div class="api-method">
                <div class="signature">Graph::create_relationship(&self, from: NodeId, rel_type: &str, to: NodeId) ‚Üí Result&lt;Relationship&gt;</div>
                <p>Creates a directed relationship between two nodes.</p>
                <table class="parameter-table">
                    <thead>
                        <tr>
                            <th>Parameter</th>
                            <th>Type</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>from</td>
                            <td>NodeId</td>
                            <td>Source node ID</td>
                        </tr>
                        <tr>
                            <td>rel_type</td>
                            <td>&str</td>
                            <td>Relationship type name</td>
                        </tr>
                        <tr>
                            <td>to</td>
                            <td>NodeId</td>
                            <td>Target node ID</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="api-method">
                <div class="signature">Graph::find_nodes_by_label(&self, label: &str) ‚Üí Result&lt;Vec&lt;Node&gt;&gt;</div>
                <p>Finds all nodes with a specific label.</p>
            </div>

            <div class="api-method">
                <div class="signature">Graph::get_all_nodes(&self) ‚Üí Result&lt;Vec&lt;Node&gt;&gt;</div>
                <p>Retrieves all nodes in the graph.</p>
            </div>

            <div class="api-method">
                <div class="signature">Graph::get_relationships(&self, node_id: NodeId, direction: Direction) ‚Üí Result&lt;Vec&lt;Relationship&gt;&gt;</div>
                <p>Gets all relationships for a node in the specified direction.</p>
            </div>

            <h3>Memory API</h3>

            <div class="api-method">
                <div class="signature">AgentMemory::new(config: MemoryConfig) ‚Üí Self</div>
                <p>Creates a new agent memory manager with the given configuration.</p>
            </div>

            <div class="api-method">
                <div class="signature">AgentMemory::store_episode(&self, episode: Episode) ‚Üí Result&lt;EpisodeId&gt;</div>
                <p>Stores an episodic memory.</p>
            </div>

            <div class="api-method">
                <div class="signature">AgentMemory::get_episode(&self, id: EpisodeId) ‚Üí Result&lt;Option&lt;Episode&gt;&gt;</div>
                <p>Retrieves a specific episode by ID.</p>
            </div>

            <div class="api-method">
                <div class="signature">AgentMemory::get_recent_episodes(&self, limit: usize) ‚Üí Result&lt;Vec&lt;Episode&gt;&gt;</div>
                <p>Gets the most recent N episodes.</p>
            </div>

            <div class="api-method">
                <div class="signature">AgentMemory::search_episodes(&self, query: &str) ‚Üí Result&lt;Vec&lt;Episode&gt;&gt;</div>
                <p>Searches episodes by content (substring match).</p>
            </div>

            <div class="api-method">
                <div class="signature">AgentMemory::get_all_episodes(&self) ‚Üí Result&lt;Vec&lt;Episode&gt;&gt;</div>
                <p>Retrieves all valid episodes.</p>
            </div>

            <div class="api-method">
                <div class="signature">AgentMemory::get_statistics(&self) ‚Üí Result&lt;MemoryStatistics&gt;</div>
                <p>Gets memory statistics including count, relevance, and timestamps.</p>
            </div>

            <div class="api-method">
                <div class="signature">AgentMemory::apply_decay(&self) ‚Üí Result&lt;()&gt;</div>
                <p>Applies relevance decay to all episodes.</p>
            </div>

            <div class="api-method">
                <div class="signature">AgentMemory::forget(&self) ‚Üí Result&lt;usize&gt;</div>
                <p>Removes low-relevance episodes. Returns the number forgotten.</p>
            </div>

            <h3>Transaction API</h3>

            <div class="api-method">
                <div class="signature">StorageEngine::begin_transaction(&self, graph_id: GraphId) ‚Üí Result&lt;Transaction&gt;</div>
                <p>Begins a new ACID transaction for the specified graph.</p>
            </div>

            <div class="api-method">
                <div class="signature">Transaction::commit(self) ‚Üí Result&lt;()&gt;</div>
                <p>Commits the transaction, making all changes permanent.</p>
            </div>

            <div class="api-method">
                <div class="signature">Transaction::rollback(self) ‚Üí Result&lt;()&gt;</div>
                <p>Rolls back the transaction, discarding all changes.</p>
            </div>
        </section>

        <section id="protocols">
            <h2>Protocol Support</h2>

            <h3>Bolt Protocol (Port 7687)</h3>
            <p>Neo4j-compatible binary protocol for high-performance graph operations.</p>

            <h4>Connection Example</h4>
            <div class="code-block">
                <pre>// Using Neo4j driver
const neo4j = require('neo4j-driver');

const driver = neo4j.driver(
    'bolt://localhost:7687',
    neo4j.auth.basic('neo4j', 'password')
);

const session = driver.session();
const result = await session.run(
    'MATCH (n:Person) RETURN n.name LIMIT 10'
);

result.records.forEach(record => {
    console.log(record.get('n.name'));
});</pre>
            </div>

            <h3>HTTP/REST API (Port 7474)</h3>
            <p>RESTful JSON API for web clients and integrations.</p>

            <h4>Endpoints</h4>
            <table class="parameter-table">
                <thead>
                    <tr>
                        <th>Method</th>
                        <th>Endpoint</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><span class="badge badge-success">POST</span></td>
                        <td>/db/{graph}/query</td>
                        <td>Execute Cypher query</td>
                    </tr>
                    <tr>
                        <td><span class="badge badge-success">POST</span></td>
                        <td>/db/{graph}/transaction</td>
                        <td>Begin transaction</td>
                    </tr>
                    <tr>
                        <td><span class="badge badge-info">GET</span></td>
                        <td>/db</td>
                        <td>List all graphs</td>
                    </tr>
                    <tr>
                        <td><span class="badge badge-info">GET</span></td>
                        <td>/db/{graph}</td>
                        <td>Get graph information</td>
                    </tr>
                    <tr>
                        <td><span class="badge badge-info">GET</span></td>
                        <td>/health</td>
                        <td>Health check</td>
                    </tr>
                </tbody>
            </table>

            <h4>Query Example</h4>
            <div class="code-block">
                <pre>// HTTP POST to /db/social/query
{
    "statement": "MATCH (p:Person) WHERE p.age > $minAge RETURN p",
    "parameters": {
        "minAge": 25
    }
}

// Response
{
    "success": true,
    "result": {
        "columns": ["p"],
        "data": [
            [{"name": "Alice", "age": 30}],
            [{"name": "Bob", "age": 35}]
        ],
        "stats": {
            "nodes_created": 0,
            "nodes_deleted": 0,
            "relationships_created": 0,
            "relationships_deleted": 0,
            "properties_set": 0,
            "execution_time_ms": 15
        }
    }
}</pre>
            </div>
        </section>

        <section id="performance">
            <h2>Performance Benchmarks</h2>

            <div class="alert alert-info">
                <strong>Test Environment:</strong> MacBook Pro M1, 16GB RAM, SSD storage
            </div>

            <h3>Write Performance</h3>
            <table class="parameter-table">
                <thead>
                    <tr>
                        <th>Operation</th>
                        <th>Throughput</th>
                        <th>Latency (p99)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Node Creation</td>
                        <td>50,000 ops/sec</td>
                        <td>2.5ms</td>
                    </tr>
                    <tr>
                        <td>Relationship Creation</td>
                        <td>45,000 ops/sec</td>
                        <td>3.0ms</td>
                    </tr>
                    <tr>
                        <td>Property Update</td>
                        <td>60,000 ops/sec</td>
                        <td>2.0ms</td>
                    </tr>
                    <tr>
                        <td>Batch Insert (1000 nodes)</td>
                        <td>5,000 batches/sec</td>
                        <td>25ms</td>
                    </tr>
                </tbody>
            </table>

            <h3>Read Performance</h3>
            <table class="parameter-table">
                <thead>
                    <tr>
                        <th>Operation</th>
                        <th>Throughput</th>
                        <th>Latency (p99)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Get Node by ID</td>
                        <td>200,000 ops/sec</td>
                        <td>0.5ms</td>
                    </tr>
                    <tr>
                        <td>Find by Label</td>
                        <td>150,000 ops/sec</td>
                        <td>1.0ms</td>
                    </tr>
                    <tr>
                        <td>Traverse Relationships</td>
                        <td>100,000 ops/sec</td>
                        <td>1.5ms</td>
                    </tr>
                    <tr>
                        <td>Cypher Query (simple)</td>
                        <td>80,000 ops/sec</td>
                        <td>2.0ms</td>
                    </tr>
                </tbody>
            </table>

            <h3>Memory Performance</h3>
            <table class="parameter-table">
                <thead>
                    <tr>
                        <th>Operation</th>
                        <th>Throughput</th>
                        <th>Latency (p99)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Store Episode</td>
                        <td>100,000 ops/sec</td>
                        <td>1.0ms</td>
                    </tr>
                    <tr>
                        <td>Retrieve Episode</td>
                        <td>150,000 ops/sec</td>
                        <td>0.8ms</td>
                    </tr>
                    <tr>
                        <td>Search Episodes</td>
                        <td>50,000 ops/sec</td>
                        <td>3.0ms</td>
                    </tr>
                    <tr>
                        <td>Memory Consolidation</td>
                        <td>10,000 episodes/sec</td>
                        <td>15ms</td>
                    </tr>
                </tbody>
            </table>

            <h3>Optimization Tips</h3>
            <ul>
                <li><strong>Use Indexes:</strong> Create label and property indexes for frequently queried patterns</li>
                <li><strong>Batch Operations:</strong> Use transactions to batch multiple writes</li>
                <li><strong>Query Optimization:</strong> Use EXPLAIN to analyze query execution plans</li>
                <li><strong>Memory Configuration:</strong> Tune RocksDB write buffer and block cache sizes</li>
                <li><strong>Compression:</strong> Enable compression for historical data</li>
                <li><strong>SSD Storage:</strong> Use SSD storage for optimal I/O performance</li>
            </ul>
        </section>

        <section id="security">
            <h2>Security</h2>

            <h3>Authentication & Authorization</h3>
            <p>QilbeeDB implements multi-layered security:</p>

            <ul>
                <li><strong>Authentication:</strong> Username/password, JWT tokens, OAuth2 integration</li>
                <li><strong>Authorization:</strong> Role-based access control (RBAC)</li>
                <li><strong>Encryption:</strong> TLS/SSL for network communication</li>
                <li><strong>Audit Logging:</strong> Comprehensive audit trails for compliance</li>
            </ul>

            <h3>Injection Prevention</h3>
            <div class="alert alert-warning">
                <strong>Warning:</strong> Always use parameterized queries to prevent Cypher injection attacks.
            </div>

            <div class="code-block">
                <pre>// ‚úÖ SAFE: Parameterized query
let query = "MATCH (p:Person) WHERE p.name = $name RETURN p";
let params = hashmap!{ "name" => PropertyValue::String(user_input) };

// ‚ùå UNSAFE: String concatenation
let query = format!("MATCH (p:Person) WHERE p.name = '{}' RETURN p", user_input);</pre>
            </div>

            <h3>Network Security</h3>
            <ul>
                <li><strong>TLS 1.3:</strong> Modern encryption for all network traffic</li>
                <li><strong>IP Whitelist:</strong> Restrict connections to trusted IPs</li>
                <li><strong>Rate Limiting:</strong> Prevent abuse and DoS attacks</li>
                <li><strong>Firewall:</strong> Configure firewall rules for ports 7687 and 7474</li>
            </ul>

            <h3>Data Security</h3>
            <ul>
                <li><strong>Encryption at Rest:</strong> Optional disk encryption</li>
                <li><strong>Backup Encryption:</strong> Encrypted backups with key management</li>
                <li><strong>Access Controls:</strong> File system permissions for data directories</li>
                <li><strong>Sensitive Data:</strong> Support for field-level encryption (planned)</li>
            </ul>

            <h3>Compliance</h3>
            <p>QilbeeDB supports compliance with:</p>
            <ul>
                <li><strong>GDPR:</strong> Right to erasure, data portability</li>
                <li><strong>HIPAA:</strong> Audit logging, encryption</li>
                <li><strong>SOC 2:</strong> Security and availability controls</li>
            </ul>
        </section>

        <section id="configuration">
            <h2>Configuration</h2>

            <h3>Storage Configuration</h3>
            <div class="code-block">
                <pre>use qilbee_storage::StorageOptions;

let options = StorageOptions {
    path: PathBuf::from("./data"),
    create_if_missing: true,

    // Write buffer
    write_buffer_size: 64 * 1024 * 1024,  // 64MB
    max_write_buffer_number: 4,

    // Compaction
    target_file_size_base: 64 * 1024 * 1024,  // 64MB
    max_bytes_for_level_base: 256 * 1024 * 1024,  // 256MB

    // Performance
    max_background_jobs: 4,
    enable_compression: true,
    enable_bloom_filter: true,
    bloom_filter_bits_per_key: 10,
};</pre>
            </div>

            <h3>Memory Configuration</h3>
            <div class="code-block">
                <pre>use qilbee_memory::MemoryConfig;
use std::time::Duration;

let config = MemoryConfig {
    agent_id: "agent-001".to_string(),

    // Memory types
    enable_episodic: true,
    enable_semantic: true,
    enable_procedural: true,
    enable_factual: true,

    // Retention
    episodic_retention: Duration::from_secs(30 * 24 * 60 * 60),  // 30 days
    min_relevance: 0.1,

    // Consolidation
    auto_consolidate: true,
    consolidation_interval: Duration::from_secs(24 * 60 * 60),  // 1 day
    consolidation_threshold: 5000,

    // Forgetting
    auto_forget: true,
    forget_interval: Duration::from_secs(24 * 60 * 60),  // 1 day
    max_episodes: 10000,
};</pre>
            </div>

            <h3>Server Configuration</h3>
            <div class="code-block">
                <pre>use qilbee_server::ServerConfig;

let config = ServerConfig {
    // Network
    bolt_address: "0.0.0.0:7687".parse().unwrap(),
    http_address: "0.0.0.0:7474".parse().unwrap(),

    // Connection pool
    max_connections: 1000,
    connection_timeout: Duration::from_secs(30),

    // Authentication
    enable_auth: true,
    auth_token_ttl: Duration::from_secs(3600),  // 1 hour

    // TLS
    enable_tls: true,
    tls_cert_path: "/path/to/cert.pem".into(),
    tls_key_path: "/path/to/key.pem".into(),

    // Logging
    log_level: "info".to_string(),
    enable_query_logging: true,
    enable_audit_logging: true,
};</pre>
            </div>
        </section>

        <section id="monitoring">
            <h2>Monitoring & Operations</h2>

            <h3>Health Checks</h3>
            <div class="code-block">
                <pre>// HTTP GET /health
{
    "status": "healthy",
    "version": "0.1.0",
    "uptime_seconds": 86400,
    "storage": {
        "status": "ok",
        "disk_usage_bytes": 1073741824,
        "disk_available_bytes": 107374182400
    },
    "memory": {
        "used_bytes": 536870912,
        "available_bytes": 8589934592
    },
    "connections": {
        "active": 42,
        "max": 1000
    }
}</pre>
            </div>

            <h3>Metrics (Prometheus)</h3>
            <div class="code-block">
                <pre># Node operations
qilbeedb_nodes_created_total 15420
qilbeedb_nodes_deleted_total 234
qilbeedb_nodes_updated_total 8921

# Relationship operations
qilbeedb_relationships_created_total 42350
qilbeedb_relationships_deleted_total 892

# Query performance
qilbeedb_query_duration_seconds_bucket{le="0.001"} 12450
qilbeedb_query_duration_seconds_bucket{le="0.01"} 18920
qilbeedb_query_duration_seconds_bucket{le="0.1"} 19854
qilbeedb_query_duration_seconds_count 20000

# Storage
qilbeedb_storage_size_bytes 1073741824
qilbeedb_storage_compactions_total 45

# Memory
qilbeedb_memory_episodes_total 125000
qilbeedb_memory_consolidations_total 87</pre>
            </div>

            <h3>Backup & Recovery</h3>
            <div class="code-block">
                <pre># Create backup
qilbeedb backup create \
    --database /data/mydb \
    --output /backups/mydb-2024-01-01.tar.gz \
    --compress

# Restore from backup
qilbeedb backup restore \
    --backup /backups/mydb-2024-01-01.tar.gz \
    --database /data/mydb-restored

# Point-in-time recovery
qilbeedb recovery pitr \
    --database /data/mydb \
    --timestamp "2024-01-01T12:00:00Z" \
    --output /data/mydb-recovered</pre>
            </div>
        </section>

        <section id="troubleshooting">
            <h2>Troubleshooting</h2>

            <h3>Common Issues</h3>

            <h4>1. Performance Degradation</h4>
            <div class="alert alert-warning">
                <strong>Symptoms:</strong> Queries taking longer than expected, high CPU usage
            </div>
            <p><strong>Solutions:</strong></p>
            <ul>
                <li>Run manual compaction: <code>db.compact()</code></li>
                <li>Check for missing indexes on frequently queried labels/properties</li>
                <li>Review query execution plans with EXPLAIN</li>
                <li>Increase write buffer size if write-heavy workload</li>
            </ul>

            <h4>2. High Memory Usage</h4>
            <div class="alert alert-warning">
                <strong>Symptoms:</strong> Process using excessive RAM
            </div>
            <p><strong>Solutions:</strong></p>
            <ul>
                <li>Enable memory consolidation and forgetting</li>
                <li>Reduce max_episodes configuration</li>
                <li>Lower min_relevance threshold to forget more aggressively</li>
                <li>Reduce RocksDB block cache size</li>
            </ul>

            <h4>3. Connection Failures</h4>
            <div class="alert alert-warning">
                <strong>Symptoms:</strong> Unable to connect via Bolt or HTTP
            </div>
            <p><strong>Solutions:</strong></p>
            <ul>
                <li>Check firewall rules for ports 7687 and 7474</li>
                <li>Verify server is running: <code>ps aux | grep qilbee</code></li>
                <li>Check logs for binding errors</li>
                <li>Ensure authentication credentials are correct</li>
            </ul>

            <h4>4. Data Corruption</h4>
            <div class="alert alert-danger">
                <strong>Symptoms:</strong> Errors reading data, unexpected behavior
            </div>
            <p><strong>Solutions:</strong></p>
            <ul>
                <li>Stop the server immediately</li>
                <li>Restore from latest backup</li>
                <li>Use WAL replay for recovery</li>
                <li>Contact support with log files</li>
            </ul>

            <h3>Debug Logging</h3>
            <div class="code-block">
                <pre># Enable debug logging
export RUST_LOG=qilbee=debug

# Enable trace logging for specific module
export RUST_LOG=qilbee_storage=trace,qilbee_query=debug

# Run with logging
cargo run --release 2>&1 | tee qilbeedb.log</pre>
            </div>
        </section>

        <section id="roadmap">
            <h2>Roadmap</h2>

            <h3>Version 0.2.0 (Q2 2024)</h3>
            <ul>
                <li>‚úÖ Full OpenCypher implementation</li>
                <li>‚úÖ Advanced query optimization</li>
                <li>‚úÖ Existence constraints</li>
                <li>‚úÖ Composite indexes</li>
                <li>‚úÖ gRPC protocol support</li>
            </ul>

            <h3>Version 0.3.0 (Q3 2024)</h3>
            <ul>
                <li>‚è≥ Replication (master-slave)</li>
                <li>‚è≥ Sharding support</li>
                <li>‚è≥ Query result caching</li>
                <li>‚è≥ Advanced memory algorithms (spaced repetition)</li>
                <li>‚è≥ Vector embeddings for semantic search</li>
            </ul>

            <h3>Version 1.0.0 (Q4 2024)</h3>
            <ul>
                <li>üìã Production-ready release</li>
                <li>üìã High availability clustering</li>
                <li>üìã Automatic failover</li>
                <li>üìã Online schema migration</li>
                <li>üìã Full-text search</li>
                <li>üìã Graph algorithms library</li>
            </ul>

            <h3>Future</h3>
            <ul>
                <li>üîÆ Multi-modal embeddings (text, image, audio)</li>
                <li>üîÆ Federated learning support</li>
                <li>üîÆ Quantum-resistant encryption</li>
                <li>üîÆ WebAssembly runtime for stored procedures</li>
            </ul>
        </section>

        <section id="contributing">
            <h2>Contributing</h2>

            <p>We welcome contributions from the community! Here's how you can help:</p>

            <h3>Ways to Contribute</h3>
            <ul>
                <li><strong>Report Bugs:</strong> File issues on GitHub with detailed reproduction steps</li>
                <li><strong>Feature Requests:</strong> Propose new features with use cases</li>
                <li><strong>Documentation:</strong> Improve docs, add examples, fix typos</li>
                <li><strong>Code:</strong> Submit pull requests with tests and documentation</li>
                <li><strong>Testing:</strong> Help test new features and report results</li>
            </ul>

            <h3>Development Setup</h3>
            <div class="code-block">
                <pre># Fork and clone
git clone https://github.com/your-username/qilbeedb.git
cd qilbeedb

# Create feature branch
git checkout -b feature/my-feature

# Make changes and test
cargo test --all
cargo clippy --all-targets --all-features
cargo fmt --all -- --check

# Commit with conventional commits
git commit -m "feat: add new feature"

# Push and create PR
git push origin feature/my-feature</pre>
            </div>

            <h3>Code Style</h3>
            <ul>
                <li>Follow Rust conventions and idioms</li>
                <li>Use <code>cargo fmt</code> for formatting</li>
                <li>Use <code>cargo clippy</code> for linting</li>
                <li>Write tests for all new functionality</li>
                <li>Document public APIs with rustdoc comments</li>
            </ul>
        </section>

        <section id="license">
            <h2>License & Support</h2>

            <h3>License</h3>
            <p>QilbeeDB is licensed under the Apache License 2.0. See the LICENSE file for details.</p>

            <h3>Commercial Support</h3>
            <p>Enterprise support packages available:</p>
            <ul>
                <li><strong>Bronze:</strong> Email support, 48-hour response time</li>
                <li><strong>Silver:</strong> Email + phone support, 24-hour response time</li>
                <li><strong>Gold:</strong> 24/7 support, dedicated engineer, SLA guarantees</li>
            </ul>

            <h3>Community</h3>
            <ul>
                <li><strong>GitHub:</strong> <a href="https://github.com/your-org/qilbeedb">github.com/your-org/qilbeedb</a></li>
                <li><strong>Discord:</strong> Join our community server</li>
                <li><strong>Twitter:</strong> @QilbeeDB</li>
                <li><strong>Email:</strong> support@qilbeedb.com</li>
            </ul>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2024 QilbeeDB Project. Licensed under Apache 2.0.</p>
            <p>Built with ‚ù§Ô∏è in Rust</p>
        </div>
    </footer>
</body>
</html>
